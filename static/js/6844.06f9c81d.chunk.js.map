{"version":3,"file":"static/js/6844.06f9c81d.chunk.js","mappings":"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","sources":["../node_modules/@tsparticles/updater-out-modes/browser/Utils.js","../node_modules/@tsparticles/updater-out-modes/browser/BounceOutMode.js","../node_modules/@tsparticles/updater-out-modes/browser/DestroyOutMode.js","../node_modules/@tsparticles/updater-out-modes/browser/NoneOutMode.js","../node_modules/@tsparticles/updater-out-modes/browser/OutOutMode.js","../node_modules/@tsparticles/updater-out-modes/browser/OutOfCanvasUpdater.js"],"sourcesContent":["import { getRangeValue } from \"@tsparticles/engine\";\nconst minVelocity = 0, boundsMin = 0;\nexport function bounceHorizontal(data) {\n    if ((data.outMode !== \"bounce\" && data.outMode !== \"split\") ||\n        (data.direction !== \"left\" && data.direction !== \"right\")) {\n        return;\n    }\n    if (data.bounds.right < boundsMin && data.direction === \"left\") {\n        data.particle.position.x = data.size + data.offset.x;\n    }\n    else if (data.bounds.left > data.canvasSize.width && data.direction === \"right\") {\n        data.particle.position.x = data.canvasSize.width - data.size - data.offset.x;\n    }\n    const velocity = data.particle.velocity.x;\n    let bounced = false;\n    if ((data.direction === \"right\" &&\n        data.bounds.right >= data.canvasSize.width &&\n        velocity > minVelocity) ||\n        (data.direction === \"left\" && data.bounds.left <= boundsMin && velocity < minVelocity)) {\n        const newVelocity = getRangeValue(data.particle.options.bounce.horizontal.value);\n        data.particle.velocity.x *= -newVelocity;\n        bounced = true;\n    }\n    if (!bounced) {\n        return;\n    }\n    const minPos = data.offset.x + data.size;\n    if (data.bounds.right >= data.canvasSize.width && data.direction === \"right\") {\n        data.particle.position.x = data.canvasSize.width - minPos;\n    }\n    else if (data.bounds.left <= boundsMin && data.direction === \"left\") {\n        data.particle.position.x = minPos;\n    }\n    if (data.outMode === \"split\") {\n        data.particle.destroy();\n    }\n}\nexport function bounceVertical(data) {\n    if ((data.outMode !== \"bounce\" && data.outMode !== \"split\") ||\n        (data.direction !== \"bottom\" && data.direction !== \"top\")) {\n        return;\n    }\n    if (data.bounds.bottom < boundsMin && data.direction === \"top\") {\n        data.particle.position.y = data.size + data.offset.y;\n    }\n    else if (data.bounds.top > data.canvasSize.height && data.direction === \"bottom\") {\n        data.particle.position.y = data.canvasSize.height - data.size - data.offset.y;\n    }\n    const velocity = data.particle.velocity.y;\n    let bounced = false;\n    if ((data.direction === \"bottom\" &&\n        data.bounds.bottom >= data.canvasSize.height &&\n        velocity > minVelocity) ||\n        (data.direction === \"top\" && data.bounds.top <= boundsMin && velocity < minVelocity)) {\n        const newVelocity = getRangeValue(data.particle.options.bounce.vertical.value);\n        data.particle.velocity.y *= -newVelocity;\n        bounced = true;\n    }\n    if (!bounced) {\n        return;\n    }\n    const minPos = data.offset.y + data.size;\n    if (data.bounds.bottom >= data.canvasSize.height && data.direction === \"bottom\") {\n        data.particle.position.y = data.canvasSize.height - minPos;\n    }\n    else if (data.bounds.top <= boundsMin && data.direction === \"top\") {\n        data.particle.position.y = minPos;\n    }\n    if (data.outMode === \"split\") {\n        data.particle.destroy();\n    }\n}\n","import { calculateBounds, } from \"@tsparticles/engine\";\nimport { bounceHorizontal, bounceVertical } from \"./Utils.js\";\nexport class BounceOutMode {\n    constructor(container) {\n        this.container = container;\n        this.modes = [\n            \"bounce\",\n            \"split\",\n        ];\n    }\n    update(particle, direction, delta, outMode) {\n        if (!this.modes.includes(outMode)) {\n            return;\n        }\n        const container = this.container;\n        let handled = false;\n        for (const [, plugin] of container.plugins) {\n            if (plugin.particleBounce !== undefined) {\n                handled = plugin.particleBounce(particle, delta, direction);\n            }\n            if (handled) {\n                break;\n            }\n        }\n        if (handled) {\n            return;\n        }\n        const pos = particle.getPosition(), offset = particle.offset, size = particle.getRadius(), bounds = calculateBounds(pos, size), canvasSize = container.canvas.size;\n        bounceHorizontal({ particle, outMode, direction, bounds, canvasSize, offset, size });\n        bounceVertical({ particle, outMode, direction, bounds, canvasSize, offset, size });\n    }\n}\n","import { Vector, getDistances, isPointInside, } from \"@tsparticles/engine\";\nconst minVelocity = 0;\nexport class DestroyOutMode {\n    constructor(container) {\n        this.container = container;\n        this.modes = [\"destroy\"];\n    }\n    update(particle, direction, _delta, outMode) {\n        if (!this.modes.includes(outMode)) {\n            return;\n        }\n        const container = this.container;\n        switch (particle.outType) {\n            case \"normal\":\n            case \"outside\":\n                if (isPointInside(particle.position, container.canvas.size, Vector.origin, particle.getRadius(), direction)) {\n                    return;\n                }\n                break;\n            case \"inside\": {\n                const { dx, dy } = getDistances(particle.position, particle.moveCenter), { x: vx, y: vy } = particle.velocity;\n                if ((vx < minVelocity && dx > particle.moveCenter.radius) ||\n                    (vy < minVelocity && dy > particle.moveCenter.radius) ||\n                    (vx >= minVelocity && dx < -particle.moveCenter.radius) ||\n                    (vy >= minVelocity && dy < -particle.moveCenter.radius)) {\n                    return;\n                }\n                break;\n            }\n        }\n        container.particles.remove(particle, undefined, true);\n    }\n}\n","import { Vector, isPointInside, } from \"@tsparticles/engine\";\nconst minVelocity = 0;\nexport class NoneOutMode {\n    constructor(container) {\n        this.container = container;\n        this.modes = [\"none\"];\n    }\n    update(particle, direction, delta, outMode) {\n        if (!this.modes.includes(outMode)) {\n            return;\n        }\n        if ((particle.options.move.distance.horizontal &&\n            (direction === \"left\" || direction === \"right\")) ??\n            (particle.options.move.distance.vertical &&\n                (direction === \"top\" || direction === \"bottom\"))) {\n            return;\n        }\n        const gravityOptions = particle.options.move.gravity, container = this.container, canvasSize = container.canvas.size, pRadius = particle.getRadius();\n        if (!gravityOptions.enable) {\n            if ((particle.velocity.y > minVelocity && particle.position.y <= canvasSize.height + pRadius) ||\n                (particle.velocity.y < minVelocity && particle.position.y >= -pRadius) ||\n                (particle.velocity.x > minVelocity && particle.position.x <= canvasSize.width + pRadius) ||\n                (particle.velocity.x < minVelocity && particle.position.x >= -pRadius)) {\n                return;\n            }\n            if (!isPointInside(particle.position, container.canvas.size, Vector.origin, pRadius, direction)) {\n                container.particles.remove(particle);\n            }\n        }\n        else {\n            const position = particle.position;\n            if ((!gravityOptions.inverse &&\n                position.y > canvasSize.height + pRadius &&\n                direction === \"bottom\") ||\n                (gravityOptions.inverse && position.y < -pRadius && direction === \"top\")) {\n                container.particles.remove(particle);\n            }\n        }\n    }\n}\n","import { Vector, calculateBounds, getDistances, getRandom, isPointInside, randomInRange, } from \"@tsparticles/engine\";\nconst minVelocity = 0, minDistance = 0;\nexport class OutOutMode {\n    constructor(container) {\n        this.container = container;\n        this.modes = [\"out\"];\n    }\n    update(particle, direction, delta, outMode) {\n        if (!this.modes.includes(outMode)) {\n            return;\n        }\n        const container = this.container;\n        switch (particle.outType) {\n            case \"inside\": {\n                const { x: vx, y: vy } = particle.velocity;\n                const circVec = Vector.origin;\n                circVec.length = particle.moveCenter.radius;\n                circVec.angle = particle.velocity.angle + Math.PI;\n                circVec.addTo(Vector.create(particle.moveCenter));\n                const { dx, dy } = getDistances(particle.position, circVec);\n                if ((vx <= minVelocity && dx >= minDistance) ||\n                    (vy <= minVelocity && dy >= minDistance) ||\n                    (vx >= minVelocity && dx <= minDistance) ||\n                    (vy >= minVelocity && dy <= minDistance)) {\n                    return;\n                }\n                particle.position.x = Math.floor(randomInRange({\n                    min: 0,\n                    max: container.canvas.size.width,\n                }));\n                particle.position.y = Math.floor(randomInRange({\n                    min: 0,\n                    max: container.canvas.size.height,\n                }));\n                const { dx: newDx, dy: newDy } = getDistances(particle.position, particle.moveCenter);\n                particle.direction = Math.atan2(-newDy, -newDx);\n                particle.velocity.angle = particle.direction;\n                break;\n            }\n            default: {\n                if (isPointInside(particle.position, container.canvas.size, Vector.origin, particle.getRadius(), direction)) {\n                    return;\n                }\n                switch (particle.outType) {\n                    case \"outside\": {\n                        particle.position.x =\n                            Math.floor(randomInRange({\n                                min: -particle.moveCenter.radius,\n                                max: particle.moveCenter.radius,\n                            })) + particle.moveCenter.x;\n                        particle.position.y =\n                            Math.floor(randomInRange({\n                                min: -particle.moveCenter.radius,\n                                max: particle.moveCenter.radius,\n                            })) + particle.moveCenter.y;\n                        const { dx, dy } = getDistances(particle.position, particle.moveCenter);\n                        if (particle.moveCenter.radius) {\n                            particle.direction = Math.atan2(dy, dx);\n                            particle.velocity.angle = particle.direction;\n                        }\n                        break;\n                    }\n                    case \"normal\": {\n                        const warp = particle.options.move.warp, canvasSize = container.canvas.size, newPos = {\n                            bottom: canvasSize.height + particle.getRadius() + particle.offset.y,\n                            left: -particle.getRadius() - particle.offset.x,\n                            right: canvasSize.width + particle.getRadius() + particle.offset.x,\n                            top: -particle.getRadius() - particle.offset.y,\n                        }, sizeValue = particle.getRadius(), nextBounds = calculateBounds(particle.position, sizeValue);\n                        if (direction === \"right\" &&\n                            nextBounds.left > canvasSize.width + particle.offset.x) {\n                            particle.position.x = newPos.left;\n                            particle.initialPosition.x = particle.position.x;\n                            if (!warp) {\n                                particle.position.y = getRandom() * canvasSize.height;\n                                particle.initialPosition.y = particle.position.y;\n                            }\n                        }\n                        else if (direction === \"left\" && nextBounds.right < -particle.offset.x) {\n                            particle.position.x = newPos.right;\n                            particle.initialPosition.x = particle.position.x;\n                            if (!warp) {\n                                particle.position.y = getRandom() * canvasSize.height;\n                                particle.initialPosition.y = particle.position.y;\n                            }\n                        }\n                        if (direction === \"bottom\" &&\n                            nextBounds.top > canvasSize.height + particle.offset.y) {\n                            if (!warp) {\n                                particle.position.x = getRandom() * canvasSize.width;\n                                particle.initialPosition.x = particle.position.x;\n                            }\n                            particle.position.y = newPos.top;\n                            particle.initialPosition.y = particle.position.y;\n                        }\n                        else if (direction === \"top\" && nextBounds.bottom < -particle.offset.y) {\n                            if (!warp) {\n                                particle.position.x = getRandom() * canvasSize.width;\n                                particle.initialPosition.x = particle.position.x;\n                            }\n                            particle.position.y = newPos.bottom;\n                            particle.initialPosition.y = particle.position.y;\n                        }\n                        break;\n                    }\n                }\n                break;\n            }\n        }\n    }\n}\n","import { BounceOutMode } from \"./BounceOutMode.js\";\nimport { DestroyOutMode } from \"./DestroyOutMode.js\";\nimport { NoneOutMode } from \"./NoneOutMode.js\";\nimport { OutOutMode } from \"./OutOutMode.js\";\nconst checkOutMode = (outModes, outMode) => {\n    return (outModes.default === outMode ||\n        outModes.bottom === outMode ||\n        outModes.left === outMode ||\n        outModes.right === outMode ||\n        outModes.top === outMode);\n};\nexport class OutOfCanvasUpdater {\n    constructor(container) {\n        this._updateOutMode = (particle, delta, outMode, direction) => {\n            for (const updater of this.updaters) {\n                updater.update(particle, direction, delta, outMode);\n            }\n        };\n        this.container = container;\n        this.updaters = [];\n    }\n    init(particle) {\n        this.updaters = [];\n        const outModes = particle.options.move.outModes;\n        if (checkOutMode(outModes, \"bounce\")) {\n            this.updaters.push(new BounceOutMode(this.container));\n        }\n        else if (checkOutMode(outModes, \"out\")) {\n            this.updaters.push(new OutOutMode(this.container));\n        }\n        else if (checkOutMode(outModes, \"destroy\")) {\n            this.updaters.push(new DestroyOutMode(this.container));\n        }\n        else if (checkOutMode(outModes, \"none\")) {\n            this.updaters.push(new NoneOutMode(this.container));\n        }\n    }\n    isEnabled(particle) {\n        return !particle.destroyed && !particle.spawning;\n    }\n    update(particle, delta) {\n        const outModes = particle.options.move.outModes;\n        this._updateOutMode(particle, delta, outModes.bottom ?? outModes.default, \"bottom\");\n        this._updateOutMode(particle, delta, outModes.left ?? outModes.default, \"left\");\n        this._updateOutMode(particle, delta, outModes.right ?? outModes.default, \"right\");\n        this._updateOutMode(particle, delta, outModes.top ?? outModes.default, \"top\");\n    }\n}\n"],"names":["minVelocity","boundsMin","BounceOutMode","container","_classCallCheck","this","modes","_createClass","key","value","particle","direction","delta","outMode","includes","_step","handled","_iterator","_createForOfIteratorHelper","plugins","s","n","done","plugin","_slicedToArray","undefined","particleBounce","err","e","f","pos","getPosition","offset","size","getRadius","bounds","calculateBounds","canvasSize","canvas","data","right","position","x","left","width","velocity","bounced","newVelocity","getRangeValue","options","bounce","horizontal","minPos","destroy","bounceHorizontal","bottom","y","top","height","vertical","bounceVertical","DestroyOutMode","_delta","outType","isPointInside","Vector","_getDistances","getDistances","moveCenter","dx","dy","_particle$velocity","vx","vy","radius","particles","remove","NoneOutMode","_ref","move","distance","gravityOptions","gravity","pRadius","enable","inverse","OutOutMode","circVec","length","angle","Math","PI","addTo","floor","randomInRange","min","max","_getDistances2","newDx","newDy","atan2","_getDistances3","warp","newPos","sizeValue","nextBounds","initialPosition","getRandom","checkOutMode","outModes","default","OutOfCanvasUpdater","_this","_updateOutMode","updaters","update","push","destroyed","spawning","_outModes$bottom","_outModes$left","_outModes$right","_outModes$top"],"sourceRoot":""}